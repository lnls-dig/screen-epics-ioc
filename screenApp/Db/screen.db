######################################################################
#
#            Fluorescent Screen Application Database
#
# Desc: These records provide a high-level abstraction layer for
#       the Fluorescent Screen application, communicating with
#       two low-level IOCs. One for the motor controller (and 
#       LED control), and another for the camera.
#
#####################################################################

#####################################################################
# LOW LEVEL IOCs INFO
#
# Desc: Records providing information regarding the motion
# controller and camera IOCs.

# Prefix of the motor controller low-level IOC
record(stringout, "$(P)$(R)MtrCtrlPrefix-Cte"){
  field(DESC, "Motor controller prefix")
  field(VAL, "$(MTR_CTRL_PREFIX)")
}

# Prefix of the camera low-level IOC
record(stringout, "$(P)$(R)CamPrefix-Cte"){
  field(DESC, "Camera prefix")
  field(VAL, "$(CAM_PREFIX)")
}

#####################################################################
# SCREEN POSITIONING
#
# Desc: Records related to screen positioning and motion.

# Fluorescent screen position set point
record(ao, "$(P)$(R)FluorScrnPos-SP"){
  field(DESC, "Set fluorescent screen position")
  field(PINI, "YES")
  field(DRVH, "1000")
  field(DRVL, "-1000")
  field(FLNK, "$(P)$(R)FluorScrnPos-RB")
}

# Fluorescent screen position readback
record(ai, "$(P)$(R)FluorScrnPos-RB"){
  field(DESC, "Fluorescent screen position RB")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)FluorScrnPos-SP")
}

# Load fluorescent screen position with encoder readback value
record(bo, "$(P)$(R)GetFluorScrnPos-Cmd"){
  field(DESC, "Load fluor scrn pos with encoder read")
  field(ONAM, "On")
  field(ZNAM, "Off")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)GetFluorScrnPosCalc")
}

# Transfer encorder position (motor RBV) to fluorescent screen position
record(calcout, "$(P)$(R)GetFluorScrnPosCalc"){
  field(DESC, "Transfer encoder read to fluor scrn pos")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.RBV")
  field(INPB, "$(P)$(R)GetFluorScrnPos-Cmd")
  field(CALC, "B")                                                    # Command state
  field(OCAL, "A")                                                    # Value to be transferred
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)FluorScrnPos-SP PP")                            # Transfer encoder position to stored position
}

# Calibration screen position set point
record(ao, "$(P)$(R)CalScrnPos-SP"){
  field(DESC, "Set calibration screen position")
  field(PINI, "YES")
  field(DRVH, "1000")
  field(DRVL, "-1000")
  field(FLNK, "$(P)$(R)CalScrnPos-RB")
}

# Calibration screen position readback
record(ai, "$(P)$(R)CalScrnPos-RB"){
  field(DESC, "Calibration screen position RB")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)CalScrnPos-SP")
}

# Load calibration screen position with encoder readback value
record(bo, "$(P)$(R)GetCalScrnPos-Cmd"){
  field(DESC, "Load cal scrn pos with encoder read")
  field(ONAM, "On")
  field(ZNAM, "Off")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)GetCalScrnPosCalc")
}

# Transfer encorder position (motor RBV) to calibration screen position
record(calcout, "$(P)$(R)GetCalScrnPosCalc"){
  field(DESC, "Transfer encoder read to cal scrn pos")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.RBV")
  field(INPB, "$(P)$(R)GetCalScrnPos-Cmd")
  field(CALC, "B")                                                    # Command state
  field(OCAL, "A")                                                    # Value to be transferred
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)CalScrnPos-SP PP")                              # Transfer encoder position to stored position
}

# None screen position set point
record(ao, "$(P)$(R)NoneScrnPos-SP"){
  field(DESC, "Set none screen position")
  field(PINI, "YES")
  field(DRVH, "1000")
  field(DRVL, "-1000")
  field(FLNK, "$(P)$(R)NoneScrnPos-RB")
}

# None screen position readback
record(ai, "$(P)$(R)NoneScrnPos-RB"){
  field(DESC, "None screen position RB")
  field(ADEL, "-1")
  field(MDEL, "-1")
  field(INP, "$(P)$(R)NoneScrnPos-SP")
}

# Load none screen position with encoder readback value
record(bo, "$(P)$(R)GetNoneScrnPos-Cmd"){
  field(DESC, "Load none scrn pos with encoder read")
  field(ONAM, "On")
  field(ZNAM, "Off")
  field(HIGH, "0.5")
  field(FLNK, "$(P)$(R)GetNoneScrnPosCalc")
}

# Transfer encorder position (motor RBV) to none screen position
record(calcout, "$(P)$(R)GetNoneScrnPosCalc"){
  field(DESC, "Transfer encoder read to none scrn pos")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.RBV")
  field(INPB, "$(P)$(R)GetNoneScrnPos-Cmd")
  field(CALC, "B")                                                    # Command state
  field(OCAL, "A")                                                    # Value to be transferred
  field(OOPT, "When Non-zero")
  field(DOPT, "Use OCAL")
  field(OUT, "$(P)$(R)NoneScrnPos-SP PP")                            # Transfer encoder position to stored position
}

# Choose screen type, and place it in front of
# the beam
record(mbbo, "$(P)$(R)ScrnType-Sel"){
  field(DESC, "Screen type")
  field(ZRVL, "0")
  field(ZRST, "None")
  field(ONVL, "1")
  field(ONST, "Calibration")
  field(TWVL, "2")
  field(TWST, "Fluorescent")
  field(FLNK, "$(P)$(R)ScrnTypeCalc")
}

# Calc to increment screen type option number
record(calc, "$(P)$(R)ScrnTypeCalc"){
  field(DESC, "Inc screen type option number")
  field(INPA, "$(P)$(R)ScrnType-Sel")
  field(CALC, "A+1")
  field(FLNK, "$(P)$(R)ScrnTypeConfig")
}

# Transfer position of selected screen type to motor
# record value.
record(seq, "$(P)$(R)ScrnTypeConfig"){
  field(DESC, "Move motor to selected scrn type pos")
  field(SELM, "Specified")
  field(SELL, "$(P)$(R)ScrnTypeCalc")
  field(DOL1, "$(P)$(R)NoneScrnPos-RB")
  field(DOL2, "$(P)$(R)CalScrnPos-RB")
  field(DOL3, "$(P)$(R)FluorScrnPos-RB")
  field(LNK1, "$(MTR_CTRL_PREFIX)AbsPos-SP PP")
  field(LNK2, "$(MTR_CTRL_PREFIX)AbsPos-SP PP")
  field(LNK3, "$(MTR_CTRL_PREFIX)AbsPos-SP PP")
}

# Screen type read calc 1
record(calc, "$(P)$(R)ScrnTypeRead1"){
  field(DESC, "Screen type read calc 1")
  field(PINI, "YES")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.RBV CPP")
  field(INPB, "$(P)$(R)CalScrnPos-RB CPP")
  field(INPC, "$(P)$(R)FluorScrnPos-RB CPP")
  field(INPD, "$(P)$(R)AcceptedErr-RB CPP")
  field(CALC, "A=B?1:(A=C?2:0)")
  field(FLNK, "$(P)$(R)ScrnTypeRead2")
}

# Screen type read calc 2
record(calcout, "$(P)$(R)ScrnTypeRead2"){
  field(DESC, "Screen type read calc 2")
  field(INPA, "$(P)$(R)ScrnTypeRead1")
  field(INPB, "$(MTR_CTRL_PREFIX)Mtr.RBV")
  field(INPC, "$(P)$(R)CalScrnPos-RB")
  field(INPD, "$(P)$(R)FluorScrnPos-RB")
  field(INPE, "$(P)$(R)AcceptedErr-RB")
  field(CALC, "A#0?A:((B<C+E)&&(B>C-E)?1:((B<D+E)&&(B>D-E)?2:0))")
  field(FLNK, "$(P)$(R)ScrnTypeRead3")
}

record(calcout, "$(P)$(R)ScrnTypeRead3"){
  field(DESC, "Screen type read calc 3")
  field(INPA, "$(P)$(R)ScrnTypeRead2")
  field(INPB, "$(MTR_CTRL_PREFIX)Mtr.RBV")
  field(INPC, "$(P)$(R)NoneScrnPos-RB")
  field(INPD, "$(P)$(R)AcceptedErr-RB")
  field(CALC, "A#0?A:((B<C+D)&&(B>C-D)?0:3)")
  field(OUT, "$(P)$(R)ScrnType-Sts PP")
}

# Screen type readback value
record(mbbi, "$(P)$(R)ScrnType-Sts"){
  field(DESC, "Screen type RB")
  field(ZRVL, "0")
  field(ZRST, "None")
  field(ONVL, "1")
  field(ONST, "Calibration")
  field(TWVL, "2")
  field(TWST, "Fluorescent")
  field(THVL, "3")
  field(THST, "Unknown")
  field(VAL, "3")
}

# Accepted Screen position error when
# defining Screen type readback value
record(ao, "$(P)$(R)AcceptedErr-SP"){
  field(DESC, "Screen pos error tolerance")
  field(PINI, "YES")
  field(DRVH, "1000")
  field(DRVL, "-1000")
  field(VAL, "1")
  field(FLNK, "$(P)$(R)AcceptedErr-RB")
}

# Accepted Screen position error RB
record(ai, "$(P)$(R)AcceptedErr-RB"){
  field(DESC, "Screen pos error tolerance RB")
  field(INP, "$(P)$(R)AcceptedErr-SP")
  field(ADEL, "-1")
  field(MDEL, "-1")
}

# Provide low level 'DoneMov-Mon' (Done Moving) PV to high level
record(bi, "$(P)$(R)DoneMov-Mon"){
  field(DESC, "Motor is done moving")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(INP, "$(MTR_CTRL_PREFIX)DoneMov-Mon CPP")
}

#####################################################################
# LED CONTROL
#
# Desc: Records for LED control.

# Digital LED Control

record(bo, "$(P)$(R)EnblLED-Sel"){
  field(DESC, "Enable/disable LEDs")
  field(PINI, "YES")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(FLNK, "$(P)$(R)EnblLED-Sts")
}

record(bi, "$(P)$(R)EnblLED-Sts"){
  field(DESC, "LEDs Enable Sts")
  field(ZNAM, "Off")
  field(ONAM, "On")
  field(INP, "$(P)$(R)EnblLED-Sel")
  field(FLNK, "$(P)$(R)ConfigLEDCalc")
}

# Analog LED Control

record(ao, "$(P)$(R)LEDPwrLvl-SP"){
  field(DESC, "LED power level")
  field(DRVH, "100")
  field(DRVL, "0")
  field(EGU, "%")
  field(FLNK, "$(P)$(R)ConfigLEDCalc")
}

# LEDLevel = 1/scaleFactor * ln(Vin / Vthold)
record(calc, "$(P)$(R)LEDPwrLvl-RB"){
  field(DESC, "LED power level RB")
  field(EGU, "%")
  field(INPA, "$(MTR_CTRL_PREFIX)AnalogOut1-RB CPP")
  field(INPB, "$(P)$(R)LEDThold-SP CPP")
  field(INPC, "$(P)$(R)LEDPwrScaleFactor-SP CPP")
  field(CALC, "(abs(A)<B)?0:((1/C)*loge(abs(A/B)))")
}

# LED control auxiliar records

# vout = Vthold * exp(LEDLevel * scaleFactor)
record(calcout, "$(P)$(R)ConfigLEDCalc"){
  field(DESC, "Configure LED calc")
  field(INPA, "$(P)$(R)EnblLED-Sel")
  field(INPB, "$(P)$(R)LEDPwrLvl-SP")
  field(INPC, "$(P)$(R)LEDThold-SP")
  field(INPD, "$(P)$(R)LEDPwrScaleFactor-SP")
  field(CALC, "A?(abs(C)*exp(abs(B*D))):0")
  field(OUT, "$(MTR_CTRL_PREFIX)AnalogOut1-SP PP")
}

# LED Power Minimum Threshold
record(ao, "$(P)$(R)LEDThold-SP"){
  field(DESC, "LED power min threshold")
  field(PINI, "YES")
  field(EGU, "V")
  field(PREC, "4")
  field(DRVH, "10")
  field(DRVL, "0")
  field(VAL, "2.5")
  field(FLNK, "$(P)$(R)LEDThold-RB")
}

record(ai, "$(P)$(R)LEDThold-RB"){
  field(DESC, "LED power min threshold RB")
  field(EGU, "V")
  field(PREC, "4")
  field(INP, "$(P)$(R)LEDThold-SP")
  field(FLNK, "$(P)$(R)ConfigLEDCalc")
}

# LED Power Level Conversion Scale Factor
record(ao, "$(P)$(R)LEDPwrScaleFactor-SP"){
  field(DESC, "LEDVolt = thold*exp(level*FACTOR)")
  field(PINI, "YES")
  field(PREC, "6")
  field(DRVH, "0.02")
  field(DRVL, "0.000001")
  field(VAL, "0.011")
  field(FLNK, "$(P)$(R)LEDPwrScaleFactor-RB")
}

record(ai, "$(P)$(R)LEDPwrScaleFactor-RB"){
  field(DESC, "LEDVolt = thold*exp(level*FACTOR)")
  field(PREC, "6")
  field(INP, "$(P)$(R)LEDPwrScaleFactor-SP")
  field(FLNK, "$(P)$(R)ConfigLEDCalc")
}

#####################################################################
# RESET
#
# Desc: Reset camera and motor controller.

# reset cmd
record(bo, "$(P)$(R)Rst-Cmd"){
  field(DESC, "Reset camera and motor controller")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(HIGH, "1")
  field(OUT, "$(P)$(R)ValidRst.A PP")
}

# validate rst cmd (make sure is non-zero)
record(calcout, "$(P)$(R)ValidRst"){
  field(DESC, "Validate reset cmd")
  field(INPA, "0")
  field(CALC, "A")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)$(R)RstSeq.PROC PP")
}

# reset sequence
record(seq, "$(P)$(R)RstSeq"){
  field(SELM, "All")
  field(DO1, "1")
  field(LNK1, "$(CAM_PREFIX)Rst-Cmd PP")
  field(DO2, "1")
  field(LNK2, "$(MTR_CTRL_PREFIX)Rst-Cmd PP")
}

# verify if reset is finished
record(calcout, "$(P)$(R)RstDoneCheck"){
  field(DESC, "Verify reset status")
  field(INPA, "$(CAM_PREFIX)RstDone-Mon CPP")
  field(INPB, "$(MTR_CTRL_PREFIX)RstDone-Mon CPP")
  field(CALC, "A && B")
  field(FLNK, "$(P)$(R)RstDone-Mon")
}

# reset done status
record(mbbi, "$(P)$(R)RstDone-Mon"){
  field(DESC, "Reset status")
  field(INP, "$(P)$(R)RstDoneCheck")
  field(ZRVL, "0")
  field(ZRST, "In Progress")
  field(ONVL, "1")
  field(ONST, "Finished")
  field(VAL, "1")
}

#####################################################################
# HOMING
#
# Desc: Command motor controller to home position,
#       moving backwards if motor direction is positive
#       or forward if motor direction is negative.

# Start homing
record(bo, "$(P)$(R)Home-Cmd"){
  field(DESC, "Command motor to home position")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(HIGH, "0.5")
  field(OUT, "$(P)$(R)HomeValid.A PP")
}

# validate the home cmd (must be non-zero)
record(calcout, "$(P)$(R)HomeValid"){
  field(DESC, "Validate home cmd")
  field(INPA, "0")
  field(INPB, "$(P)$(R)RstDone-Mon")
  field(CALC, "A && B")    # Reset must NOT be in progress
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)$(R)HomeCalc.PROC PP")
}

# choose config based on mtr direction
record(calc, "$(P)$(R)HomeCalc"){
  field(DESC, "Home direction calc")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.DIR")
  field(CALC, "A=0?3:12")
  field(FLNK, "$(P)$(R)HomeInit")
}

# Homing initialization sequece
record(seq, "$(P)$(R)HomeInit"){
  field(DESC, "Homing initialization sequence")
  field(SELM, "All")
  field(DO1, "0")
  field(LNK1, "$(P)$(R)HomeDone-Mon")
  # Use limit switch as home switch
  field(DLY2, "1")
  field(DO2, "1")
  field(LNK2, "$(MTR_CTRL_PREFIX)UseSw-Sel PP")
  field(FLNK, "$(P)$(R)HomeStart")
}

# start homing
record(seq, "$(P)$(R)HomeStart"){
  field(DESC, "Homing start sequence")
  field(SELM, "Mask")
  field(SELL, "$(P)$(R)HomeCalc")
  # enable forward homing
  field(DO1, "2")
  field(LNK1, "$(MTR_CTRL_PREFIX)HomeEnblDir-Sel PP")
  # delay homing until config is set
  field(DLY2, "1")
  # home forward
  field(DO2, "1")
  field(LNK2, "$(MTR_CTRL_PREFIX)Mtr.HOMF PP")
  # enable reverse homing
  field(DO3, "1")
  field(LNK3, "$(MTR_CTRL_PREFIX)HomeEnblDir-Sel PP")
  # delay homing until config is set
  field(DLY4, "1")
  # home reverse
  field(DO4, "1")
  field(LNK4, "$(MTR_CTRL_PREFIX)Mtr.HOMR PP")
}

# set flag when homing starts
record(calcout, "$(P)$(R)HomeStartStsCalc"){
  field(DESC, "Homing start status calc")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.DMOV")
  field(INPB, "$(P)$(R)HomeDone-Mon CPP")
  field(CALC, "(B=0)&&(A=0)")
  field(OOPT, "When Non-zero")
  field(OUT, "$(P)$(R)HomeStartStsFlag PP")
}

# homing start flag
record(bi, "$(P)$(R)HomeStartStsFlag PP"){
  field(DESC, "Home start status flag")
}

# monitor motors 'done moving' field
record(calcout, "$(P)$(R)HomeDoneMoving"){
  field(DESC, "Monitor when motors are done moving")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.DMOV CPP")
  field(INPB, "$(P)$(R)HomeStartStsFlag")
  field(CALC, "A && B")
  field(OOPT, "When Non-zero")
  # delay until 'at home' field is set for sure
  field(ODLY, "1")
  field(OUT, "$(P)$(R)HomeEndStsCalc.PROC PP")
}

# check that motor is at limit switch
# after homing is finished
record(calcout, "$(P)$(R)HomeEndStsCalc"){
  field(DESC, "Homing end status calc")
  field(INPA, "$(MTR_CTRL_PREFIX)Mtr.ATHM")
  field(INPB, "$(P)$(R)HomeDoneMoving")
  field(CALC, "(A && B)?1:2")
  field(OCAL, "0")
  field(DOPT, "Use OCAL")
  field(VAL, "1")
  field(OUT, "$(P)$(R)HomeStartStsFlag PP")
  field(FLNK, "$(P)$(R)HomeDoneUpdate")
}

# update home done
record(calcout, "$(P)$(R)HomeDoneUpdate"){
  field(DESC, "Update home done status")
  field(INPA, "$(P)$(R)HomeEndStsCalc.VAL")
  field(CALC, "A")
  field(OUT, "$(P)$(R)HomeDone-Mon PP")
}

# home done status
record(mbbi, "$(P)$(R)HomeDone-Mon"){
  field(DESC, "Homing status")
  field(ZRVL, "0")
  field(ZRST, "In Progress")
  field(ONVL, "1")
  field(ONST, "Finished")
  field(TWVL, "2")
  field(TWST, "Error")
  field(VAL, "1")
}

#####################################################################
# EGU and PREC SETTINGS
#
# Desc: Engineering units and precision are
# obtained from low-level controller IOC.

# EGU is obtained from low-level controller IOC
record(sseq, "$(P)$(R)AutoSetEGU"){
  field(DESC, "Set records with controller IOC EGU")
  field(PINI, "YES")
  field(SELM, "All")
  field(DOL1, "$(MTR_CTRL_PREFIX)Mtr.EGU CPP")
  field(DOL2, "$(MTR_CTRL_PREFIX)Mtr.EGU")
  field(DOL3, "$(MTR_CTRL_PREFIX)Mtr.EGU")
  field(DOL4, "$(MTR_CTRL_PREFIX)Mtr.EGU")
  field(DOL5, "$(MTR_CTRL_PREFIX)Mtr.EGU")
  field(DOL6, "$(MTR_CTRL_PREFIX)Mtr.EGU")
  field(LNK1, "$(P)$(R)FluorScrnPos-SP.EGU")
  field(LNK2, "$(P)$(R)FluorScrnPos-RB.EGU")
  field(LNK3, "$(P)$(R)CalScrnPos-SP.EGU")
  field(LNK4, "$(P)$(R)CalScrnPos-RB.EGU")
  field(LNK5, "$(P)$(R)AcceptedErr-SP.EGU")
  field(LNK6, "$(P)$(R)AcceptedErr-RB.EGU")
}

# PREC is obtained from low-level controller IOC
record(sseq, "$(P)$(R)AutoSetPrec"){
  field(DESC, "Set records with controller IOC PREC")
  field(PINI, "YES")
  field(SELM, "All")
  field(DOL1, "$(MTR_CTRL_PREFIX)Mtr.PREC CPP")
  field(DOL2, "$(MTR_CTRL_PREFIX)Mtr.PREC")
  field(DOL3, "$(MTR_CTRL_PREFIX)Mtr.PREC")
  field(DOL4, "$(MTR_CTRL_PREFIX)Mtr.PREC")
  field(DOL5, "$(MTR_CTRL_PREFIX)Mtr.PREC")
  field(DOL6, "$(MTR_CTRL_PREFIX)Mtr.PREC")
  field(LNK1, "$(P)$(R)FluorScrnPos-SP.PREC")
  field(LNK2, "$(P)$(R)FluorScrnPos-RB.PREC")
  field(LNK3, "$(P)$(R)CalScrnPos-SP.PREC")
  field(LNK4, "$(P)$(R)CalScrnPos-RB.PREC")
  field(LNK5, "$(P)$(R)AcceptedErr-SP.PREC")
  field(LNK6, "$(P)$(R)AcceptedErr-RB.PREC")
}

